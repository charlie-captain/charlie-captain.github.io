[{"content":"今天算是遇到一个问题, 一个View的scale改变之后, 我怎么去计算view里面的位置呢, 比如画一个点在他的某个点上, x和y需要相应进行scale换算吗?\n看完上面的内容, 很明显, scale不会改变view的宽高, 那么到底该如何进行下一步呢?\n答案就是:\n其实就跟当他没有scale的时候计算好x和y值就好了, scale属性只是说看起来缩小了, 实际内容还是在原来宽高布局的.\n记录一下, 可以看看源码, 如何实现的.\n /** * Sets the amount that the view is scaled in x around the pivot point, as a proportion of * the view's unscaled width. A value of 1 means that no scaling is applied. * * @param scaleX The scaling factor. * @see #getPivotX() * @see #getPivotY() * * @attr ref android.R.styleable#View_scaleX */ public void setScaleX(float scaleX) { if (scaleX != getScaleX()) { scaleX = sanitizeFloatPropertyValue(scaleX, \u0026quot;scaleX\u0026quot;); invalidateViewProperty(true, false); mRenderNode.setScaleX(scaleX); invalidateViewProperty(false, true); invalidateParentIfNeededAndWasQuickRejected(); notifySubtreeAccessibilityStateChangedIfNeeded(); } }  翻译过来就是:\n设置视图在枢轴点周围以x缩放的数量，作为的比例视图的未缩放宽度。值1表示不应用缩放。\n看懂非懂, 感兴趣的同学进一步看代码, 我这里就不分析了.\n","date":"2022-02-15","permalink":"https://charlie-captain.github.io/post/view%E7%9A%84scale%E5%B1%9E%E6%80%A7%E4%B8%8D%E4%BC%9A%E6%94%B9%E5%8F%98%E5%AE%BD%E9%AB%98/","tags":null,"title":"View的Scale属性不会改变宽高"},{"content":"问题 两个fragment, fragmentTest1和fragmentTest2, 初始化fragmentTest1, 代码如下:\nsupportFragmentManager.beginTransaction() .add(R.id.content, fragmentTest1, FragmentTest1::class.java.simpleName) .commit()  然后在一个点击事件跳转到fragmentTest2, 代码如下:\nval fragmentTest2 = FragmentTest2() supportFragmentManager.beginTransaction().apply { add(R.id.content, fragmentTest2,\u0026quot;FragmentTest2\u0026quot;) .show(fragmentTest2) .addToBackStack(null) .commit() }  很明显跳转没有加hide(fragmentTest1), 那么这里会发生什么问题呢?\n我们打印一下他们的生命周期,如下:\nfragmentTest1: onViewCreated fragmentTest1: onResume fragmentTest2: onViewCreated fragmentTest2: onResume  为啥fragmentTest1仍然可见, 问题出现在这了, 我们只能乖乖的加上hide(fragment1),逻辑才正常. 这是为什么呢.\n 加上hide之后, 需要重写onHiddenChanged来监听, 因为hide操作不会回调onPause\n 源码分析 分析一下add,shou,hide到底做了些什么操作导致onHiddenChanged的回调.\ncommit public int commit() { return commitInternal(false); } int commitInternal(boolean allowStateLoss) { //省略 mManager.enqueueAction(this, allowStateLoss); return mIndex; } //后面的跳转省略, 给出跳转的方法, 主要是事务抛到fragment的handler去执行 scheduleCommit(); 到 mHost.getHandler().post(mExecCommit); mExecCommit的定义如下: Runnable mExecCommit = new Runnable() { @Override public void run() { execPendingActions(); } };  execPendingActions  public boolean execPendingActions() { ensureExecReady(true); //后面省略 } private void ensureExecReady(boolean allowStateLoss) { //... try { executePostponedTransaction(null, null); } finally { mExecutingActions = false; } } private void executePostponedTransaction(ArrayList\u0026lt;BackStackRecord\u0026gt; records, ArrayList\u0026lt;Boolean\u0026gt; isRecordPop) { //遍历mPostponedTransactions // listener.completeTransaction(); }  completeTransaction  public void completeTransaction() { //省略标记 mRecord.mManager.completeExecute(mRecord, mIsBack, !canceled, true); } 终于到达完成事务的地方 void completeExecute(BackStackRecord record, boolean isPop, boolean runTransitions, boolean moveToState) { if (isPop) { //出栈 record.executePopOps(moveToState); } else { //进栈 record.executeOps(); } //省略 }  excuteOps 这个方法非常多的操作, 都是我们调用add, hide, show的时候添加进来的Op对象\n这里看看hideFragmnet\n public void hideFragment(Fragment fragment) { if (DEBUG) Log.v(TAG, \u0026quot;hide: \u0026quot; + fragment); if (!fragment.mHidden) { fragment.mHidden = true; // Toggle hidden changed so that if a fragment goes through show/hide/show // it doesn't go through the animation. fragment.mHiddenChanged = !fragment.mHiddenChanged; } }  真相大白, 看到mHiddenChanged被修改了. 但是哪里通知fragment的呢?\n在做完一系列的add,hide,show之后, 会调用moveToState, 然后会调用moveFragmentToExpectedState, 最后有一句:\nif (f.mHiddenChanged) { completeShowHideFragment(f); } 最后会调用 fragment.mHiddenChanged = false; fragment.onHiddenChanged(fragment.mHidden);  看完这里, 我们把onHiddenChanged的路径找到了.\n","date":"2022-02-15","permalink":"https://charlie-captain.github.io/post/fragment%E7%9A%84addshowhide%E4%B8%80%E5%AE%9A%E8%A6%81%E4%B8%80%E8%B5%B7%E7%94%A8%E5%90%97/","tags":null,"title":"Fragment的add,show,hide一定要一起用吗"},{"content":"问题: 为什么有的时候在进入一些页面的时候，livedata.observe{ 这里的代码会执行 }?\nLiveData源码解析  setValue  @MainThread protected void setValue(T value) { assertMainThread(\u0026quot;setValue\u0026quot;); mVersion++; //注意这个 mData = value; dispatchingValue(null); }   dispatchingValue  //省略 considerNotify(iterator.next().getValue()); //省略   considerNotify  private void considerNotify(ObserverWrapper observer) { if (!observer.mActive) { return; } // Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet. // // we still first check observer.active to keep it as the entrance for events. So even if // the observer moved to an active state, if we've not received that event, we better not // notify for a more predictable notification order. if (!observer.shouldBeActive()) { observer.activeStateChanged(false); return; } if (observer.mLastVersion \u0026gt;= mVersion) { //这里是重点 return; } observer.mLastVersion = mVersion; //noinspection unchecked observer.mObserver.onChanged((T) mData); }  关键在最后一个 if (observer.mLastVersion \u0026gt;= mVersion)\n真相大白，如果liveData调用过setValue, 之后的observe都会初始化, 如果没有调用过, 那么就不会初始化.\n总结 LiveData没有setValue, 后面不会初始化, 调用过setValue, 后面都会初始化。\n","date":"2022-02-15","permalink":"https://charlie-captain.github.io/post/livedata%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96/","tags":null,"title":"LiveData为什么会初始化"},{"content":"前景 默认初始化3个tab, 但是当联网获取到数据之后, 需要再新增一个tab,而且tab的顺序需要调整.\n源码分析 定义变量缓存所需数据 //缓存fragment private val fragments = mutableMapOf\u0026lt;Tab, Fragment\u0026gt;() //缓存fragment的ItemId private val keyIdMap = mutableMapOf\u0026lt;Tab, Int\u0026gt;() //缓存tab的上一次的排序位置 private val prePosList = mutableListOf\u0026lt;Tab\u0026gt;()  初始化的顺序\n instantiateItem getItemId //如果没有找到Fragment, 就调用下面getItem获取fragment getItem  刷新方案 getItemPosition 通过fragments获得key(tab) 然后key获得新的newIndex 如果旧的index != newIndex, 清除缓存的fragment,清除id让其重新初始化 返回POSITION_NONE,让其重新初始化 其余返回 POSITION_UNCHANGED  源码 class MainPagePagerAdapter(fragmentManager: FragmentManager) : FragmentPagerAdapter(fragmentManager, BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT) { private var tabList = listOf\u0026lt;String\u0026gt;(\u0026quot;Chat\u0026quot;, \u0026quot;Camera\u0026quot;, \u0026quot;Story\u0026quot;) private val FRAGMENT_SIZE: Int get() = tabList.size private val fragments = mutableMapOf\u0026lt;String, Fragment\u0026gt;() private val keyIdMap = mutableMapOf\u0026lt;String, Int\u0026gt;() private val prePosList = mutableListOf\u0026lt;String\u0026gt;() private var id = 0 override fun getItem(position: Int): Fragment { return getFragment(position) } private fun getFragment(position: Int): Fragment { val tab = tabList[position] var fragment = fragments[tab] if (fragment == null) { fragment = Fragment() fragments[tab] = fragment } return fragment } override fun getItemId(position: Int): Long { //这个方法是通过itemId来获取fragment,所以要自己管理一份id val key = tabList[position] var savedId = keyIdMap[key]?.toLong() if (savedId == null) { savedId = (id).toLong() keyIdMap[key] = id++ } return savedId } override fun getCount(): Int { return FRAGMENT_SIZE } override fun getItemPosition(`object`: Any): Int { var key: String? = null //找出fragment对应的key fragments.forEach loop@{ if (it.value == `object`) { key = it.key return@loop } } if (key == null) { return POSITION_UNCHANGED } //取出旧的位置, 对比新的位置, 如果不相等就需要重新创建实例 val index = prePosList.indexOf(key!!) var newIndex = -1 tabList.forEachIndexed { i, tab -\u0026gt; if (tab == key) { newIndex = i } } if (index != newIndex) { //清除缓存 fragments.remove(key!!) keyIdMap.remove(key!!) return POSITION_NONE } return POSITION_UNCHANGED } fun update(listOf: List\u0026lt;String\u0026gt;) { prePosList.clear() prePosList.addAll(tabList.toList()) tabList = listOf notifyDataSetChanged() } }  ","date":"2022-02-15","permalink":"https://charlie-captain.github.io/post/viewpager%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%9C%80%E4%BC%98%E6%96%B9%E6%A1%88/","tags":null,"title":"ViewPager动态初始化最优方案"},{"content":"流程  with  初始化glide,线程池(Engine)[默认使用GlideExecutor, 根据cpu计算线程数量,最小4个\t] 监听生命周期和网络   load 设置资源地址-资源的属性 into 为target设置request, 加入线程池开始任务  如何回调 into方法 into( glideContext.buildImageViewTarget(view, transcodeClass), /*targetListener=*/ null, requestOptions, Executors.mainThreadExecutor());  关键地方在最后一个参数, 主线程执行\nprivate static final Executor MAIN_THREAD_EXECUTOR = new Executor() { private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(@NonNull Runnable command) { handler.post(command); } };  网络下载在哪里 DecodeJob 这个是一个Runnable的任务, 我们看看run方法, 主要是runWrapped()\nprivate void runWrapped() { switch (runReason) { case INITIALIZE: //初始化 stage = getNextStage(Stage.INITIALIZE); currentGenerator = getNextGenerator(); runGenerators(); break; case SWITCH_TO_SOURCE_SERVICE: //获取资源(网络/本地) runGenerators(); break; case DECODE_DATA: //解析资源(bitmap/drawable等等) decodeFromRetrievedData(); break; default: throw new IllegalStateException(\u0026quot;Unrecognized run reason: \u0026quot; + runReason); } }  generator 有以下这几种生成器\nprivate DataFetcherGenerator getNextGenerator() { switch (stage) { case RESOURCE_CACHE: //已经修改过的缓存, 加载到view的 //from cache files containing downsampled/transformed resource data. return new ResourceCacheGenerator(decodeHelper, this); case DATA_CACHE: //原图资源缓存 //from cache files containing original unmodified source data. return new DataCacheGenerator(decodeHelper, this); case SOURCE: //源资源 //from original source data using registered {@link com.bumptech.glide.load.model.ModelLoader ModelLoaders} and the model provided for the load. return new SourceGenerator(decodeHelper, this); case FINISHED: return null; default: throw new IllegalStateException(\u0026quot;Unrecognized stage: \u0026quot; + stage); } }  网络请求处理  HttpUrlFetcher: HttpURLConnection OkHttpStreamFetcher: OkHttp  解析网络数据 ResourceDecoder\n有很多种解析器, 主要将网络数据decode成bitmap/drawable, 用于显示.\n","date":"2022-02-15","permalink":"https://charlie-captain.github.io/post/glide%E6%B5%81%E7%A8%8B/","tags":null,"title":"Glide 是如何运作的,这篇3分钟看懂"},{"content":"前言 在我跟踪到Downsampler的地方时，明明看到有log的代码，却没有日志输出，原因很明显是在Log.isLoggable(TAG, Log.VERBOSE)这里\n解决 adb shell setprop log.tag.Downsampler V  后面的V就是VERBOSE的意思，你也可以根据以下来定义\npublic static final int ASSERT = 7; public static final int DEBUG = 3; public static final int ERROR = 6; public static final int INFO = 4; public static final int VERBOSE = 2; public static final int WARN = 5;  ","date":"2021-06-09","permalink":"https://charlie-captain.github.io/post/glide/","tags":["Android"],"title":"Glide没有打印verbose的log"},{"content":"挖矿指南：新手必看 本文发于数字货币最热时段，请大家自行承担一切风险。\n前期准备 硬件设备  ASIC 矿机 这个价格较高，主要是专门为比特币设计的，现在比特币不好挖，所以不推荐小白买。 GPU显卡 选择比较多，一般打游戏的人都会有独立显卡，我这里不做推荐，大家可以参考下面网站去看收益排行在做决定。 https://minerstat.com/hardware/gpus?lang=zh  电费低于1.5元/度 电费是挖矿的成本，如果每日挖到的收益减掉成本之后赚的不超过10元，不推荐挖了，如果随便玩玩，请随意。\n开始挖矿 软件（Windows平台） 有众多的内核和软件选择，推荐小白使用界面版本，简单易用。\n开源矿工 支持90+币种，可以一键批量切换矿池、币种、钱包；批量一键升级内核、软件、驱动；一键批量超频，不依赖小飞机。 这款软件是开源的，作者也说不抽水，推荐一波。 https://ntminer.com/\n矿池 你可以根据你想挖的币选择矿池，也可以看收益来选择，我用的比较多的是鱼池（f2pool)，如果你嫌麻烦，也可以直接在火币、币安，这些比较大型的网站的矿池去挖，具体教程可以去看官网。\n软件使用  选择币种 选择矿池 填写自己矿池用户名  收益提现 如果是鱼池挖的，需要填写钱包地址，然后他会定时转钱到账。\n挖到的币，你可以币币交易换成USTD，一种类似美元的数字货币，他的价格跟美元相差无几，比较稳定，然后再把USTD换成人民币，可以看各个交易平台的规则。\n","date":"2021-05-10","permalink":"https://charlie-captain.github.io/post/%E6%8C%96%E7%9F%BF%E6%8C%87%E5%8D%97/","tags":["区块链"],"title":"挖矿指南"}]